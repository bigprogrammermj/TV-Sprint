/**
 * ========================================
 * TIMER WEBSEITE - BOMBEN-ENTSCH√ÑRFUNG STIL
 * JavaScript Countdown & Uptime Logic mit Persistierung
 * ========================================
 */

// Timer-Zieldaten definieren
const TARGET_DATES = {
    timer1: new Date('2025-09-27T23:59:59'),  // 27.09.2025
    timer2: new Date('2025-10-11T23:59:59'),  // 11.10.2025
    timer3: new Date('2026-01-01T23:59:59'),  // 01.01.2026
    timer4: new Date('2026-01-28T23:59:59')   // 28.01.2026
};

// Uptime-Start-Zeit (aus LocalStorage oder aktuell)
let UPTIME_START = null;

// App-Start-Zeit f√ºr Persistierung
let APP_START_TIME = null;

/**
 * Initialisierung der App mit Persistierung
 */
function initializeApp() {
    // Lade oder erstelle App-Start-Zeit
    const storedAppStart = localStorage.getItem('appStartTime');
    if (storedAppStart) {
        APP_START_TIME = new Date(storedAppStart);
        console.log('üì± App-Start-Zeit aus localStorage geladen:', APP_START_TIME);
    } else {
        APP_START_TIME = new Date();
        localStorage.setItem('appStartTime', APP_START_TIME.toISOString());
        console.log('üì± Neue App-Start-Zeit gesetzt:', APP_START_TIME);
    }
    
    // Uptime initialisieren
    initializeUptime();
    
    // Erste Timer-Aktualisierung
    updateAllTimers();
    
    // Synchronisiere auf die n√§chste volle Sekunde f√ºr pr√§zise Updates
    const now = new Date();
    const msUntilNextSecond = 1000 - now.getMilliseconds();
    
    setTimeout(() => {
        updateAllTimersWithAnimation();
        setInterval(updateAllTimersWithAnimation, 1000);
    }, msUntilNextSecond);
}

/**
 * Initialisierung der Uptime mit Persistierung
 */
function initializeUptime() {
    const storedStart = localStorage.getItem('uptimeStart');
    if (storedStart) {
        UPTIME_START = new Date(storedStart);
        console.log('‚è±Ô∏è Uptime-Start aus localStorage geladen:', UPTIME_START);
    } else {
        UPTIME_START = new Date();
        localStorage.setItem('uptimeStart', UPTIME_START.toISOString());
        console.log('‚è±Ô∏è Neue Uptime-Start-Zeit gesetzt:', UPTIME_START);
    }
}

/**
 * Speichere aktuellen Timer-Zustand f√ºr Persistierung
 */
function saveTimerState() {
    const currentState = {
        appStartTime: APP_START_TIME.toISOString(),
        uptimeStart: UPTIME_START.toISOString(),
        lastUpdate: new Date().toISOString(),
        targetDates: {
            timer1: TARGET_DATES.timer1.toISOString(),
            timer2: TARGET_DATES.timer2.toISOString(),
            timer3: TARGET_DATES.timer3.toISOString(),
            timer4: TARGET_DATES.timer4.toISOString()
        }
    };
    
    localStorage.setItem('timerState', JSON.stringify(currentState));
    console.log('üíæ Timer-Zustand gespeichert');
}

/**
 * Lade Timer-Zustand bei Reload/Refresh
 */
function loadTimerState() {
    const storedState = localStorage.getItem('timerState');
    if (storedState) {
        try {
            const state = JSON.parse(storedState);
            console.log('üìÇ Timer-Zustand geladen:', state);
            
            // Pr√ºfe ob Target-Dates ge√§ndert wurden
            const currentTargets = {
                timer1: TARGET_DATES.timer1.toISOString(),
                timer2: TARGET_DATES.timer2.toISOString(),
                timer3: TARGET_DATES.timer3.toISOString(),
                timer4: TARGET_DATES.timer4.toISOString()
            };
            
            // Wenn sich Target-Dates ge√§ndert haben, update den State
            if (JSON.stringify(currentTargets) !== JSON.stringify(state.targetDates)) {
                console.log('üîÑ Target-Dates haben sich ge√§ndert, aktualisiere...');
                saveTimerState();
            }
            
            return true;
        } catch (error) {
            console.error('‚ùå Fehler beim Laden des Timer-Zustands:', error);
            return false;
        }
    }
    return false;
}

/**
 * Berechnet Zeitdifferenz zwischen zwei Daten
 * @param {Date} targetDate - Zieldatum
 * @param {Date} currentDate - Aktuelles Datum
 * @returns {Object} - Zeitdifferenz-Objekt
 */
function calculateTimeDifference(targetDate, currentDate = new Date()) {
    const timeDiff = targetDate - currentDate;
    
    if (timeDiff <= 0) {
        return {
            months: 0,
            weeks: 0,
            days: 0,
            hours: 0,
            minutes: 0,
            seconds: 0,
            expired: true
        };
    }
    
    // Berechnung der Zeiteinheiten
    const totalSeconds = Math.floor(timeDiff / 1000);
    const totalMinutes = Math.floor(totalSeconds / 60);
    const totalHours = Math.floor(totalMinutes / 60);
    const totalDays = Math.floor(totalHours / 24);
    
    // Monate und Wochen berechnen
    const months = Math.floor(totalDays / 30);
    const remainingDaysAfterMonths = totalDays % 30;
    const weeks = Math.floor(remainingDaysAfterMonths / 7);
    const days = remainingDaysAfterMonths % 7;
    
    return {
        months: Math.max(0, months),
        weeks: Math.max(0, weeks),
        days: Math.max(0, days),
        hours: Math.max(0, totalHours % 24),
        minutes: Math.max(0, totalMinutes % 60),
        seconds: Math.max(0, totalSeconds % 60),
        expired: false
    };
}

/**
 * Berechnet verstrichene Zeit seit einem Startdatum
 * @param {Date} startDate - Startdatum
 * @param {Date} currentDate - Aktuelles Datum
 * @returns {Object} - Verstrichene Zeit-Objekt
 */
function calculateElapsedTime(startDate, currentDate = new Date()) {
    const timeDiff = currentDate - startDate;
    
    if (timeDiff <= 0) {
        return {
            months: 0,
            weeks: 0,
            days: 0,
            hours: 0,
            minutes: 0,
            seconds: 0
        };
    }
    
    // Berechnung der Zeiteinheiten
    const totalSeconds = Math.floor(timeDiff / 1000);
    const totalMinutes = Math.floor(totalSeconds / 60);
    const totalHours = Math.floor(totalMinutes / 60);
    const totalDays = Math.floor(totalHours / 24);
    
    // Monate und Wochen berechnen
    const months = Math.floor(totalDays / 30);
    const remainingDaysAfterMonths = totalDays % 30;
    const weeks = Math.floor(remainingDaysAfterMonths / 7);
    const days = remainingDaysAfterMonths % 7;
    
    return {
        months: Math.max(0, months),
        weeks: Math.max(0, weeks),
        days: Math.max(0, days),
        hours: Math.max(0, totalHours % 24),
        minutes: Math.max(0, totalMinutes % 60),
        seconds: Math.max(0, totalSeconds % 60)
    };
}

/**
 * Aktualisiert die Anzeige einer zweistelligen Zahl
 * @param {string} prefix - Pr√§fix f√ºr die Element-IDs
 * @param {number} value - Anzuzeigender Wert
 */
function updateDigitDisplay(prefix, value) {
    const tens = Math.floor(value / 10);
    const ones = value % 10;
    
    const tensElement = document.getElementById(`${prefix}-tens`);
    const onesElement = document.getElementById(`${prefix}-ones`);
    
    if (tensElement && onesElement) {
        const tensContent = tensElement.querySelector('.digit-content');
        const onesContent = onesElement.querySelector('.digit-content');
        
        if (tensContent && onesContent) {
            tensContent.textContent = tens;
            onesContent.textContent = ones;
        }
    }
}

/**
 * Aktualisiert einen Countdown-Timer mit synchroner Zeit
 * @param {string} timerPrefix - Pr√§fix f√ºr die Timer-IDs
 * @param {Date} targetDate - Zieldatum des Timers
 * @param {Date} currentTime - Aktuelle Zeit (f√ºr Synchronisation)
 */
function updateCountdownTimerSync(timerPrefix, targetDate, currentTime) {
    const timeDiff = calculateTimeDifference(targetDate, currentTime);
    
    updateDigitDisplay(`${timerPrefix}-months`, timeDiff.months);
    updateDigitDisplay(`${timerPrefix}-weeks`, timeDiff.weeks);
    updateDigitDisplay(`${timerPrefix}-days`, timeDiff.days);
    updateDigitDisplay(`${timerPrefix}-hours`, timeDiff.hours);
    updateDigitDisplay(`${timerPrefix}-minutes`, timeDiff.minutes);
    updateDigitDisplay(`${timerPrefix}-seconds`, timeDiff.seconds);
}

/**
 * Aktualisiert den Uptime-Counter
 * @param {Object} elapsedTime - Verstrichene Zeit-Objekt
 */
function updateUptimeDisplay(elapsedTime) {
    updateDigitDisplay('uptime-months', elapsedTime.months);
    updateDigitDisplay('uptime-weeks', elapsedTime.weeks);
    updateDigitDisplay('uptime-days', elapsedTime.days);
    updateDigitDisplay('uptime-hours', elapsedTime.hours);
    updateDigitDisplay('uptime-minutes', elapsedTime.minutes);
    updateDigitDisplay('uptime-seconds', elapsedTime.seconds);
}

/**
 * Aktualisiert alle Timer synchron
 */
function updateAllTimers() {
    // Eine einzige currentTime f√ºr alle Timer (perfekte Synchronisation)
    const currentTime = new Date();
    
    // Countdown-Timer mit synchroner Zeit aktualisieren
    updateCountdownTimerSync('timer1', TARGET_DATES.timer1, currentTime);
    updateCountdownTimerSync('timer2', TARGET_DATES.timer2, currentTime);
    updateCountdownTimerSync('timer3', TARGET_DATES.timer3, currentTime);
    updateCountdownTimerSync('timer4', TARGET_DATES.timer4, currentTime);
    
    // Uptime-Counter aktualisieren
    const elapsedTime = calculateElapsedTime(UPTIME_START, currentTime);
    updateUptimeDisplay(elapsedTime);
    
    // Zustand speichern f√ºr Persistierung
    saveTimerState();
}

/**
 * Timer-Update mit Animation (wird alle Sekunde aufgerufen)
 */
function updateAllTimersWithAnimation() {
    updateAllTimers();
    
    // Optional: Hier k√∂nnten Animationen hinzugef√ºgt werden
    // console.log('üï∞Ô∏è Timer aktualisiert:', new Date().toLocaleTimeString());
}

/**
 * Initialisiert die DOM-Elemente
 */
function initializeDOM() {
    console.log('üèóÔ∏è DOM wird initialisiert...');
    
    // Pr√ºfe ob alle n√∂tigen Elemente vorhanden sind
    const requiredElements = [
        'timer1-months-tens', 'timer1-months-ones',
        'timer2-months-tens', 'timer2-months-ones',
        'timer3-months-tens', 'timer3-months-ones',
        'timer4-months-tens', 'timer4-months-ones',
        'uptime-months-tens', 'uptime-months-ones'
    ];
    
    let allElementsFound = true;
    requiredElements.forEach(id => {
        if (!document.getElementById(id)) {
            console.error(`‚ùå Element mit ID '${id}' nicht gefunden!`);
            allElementsFound = false;
        }
    });
    
    if (allElementsFound) {
        console.log('‚úÖ Alle DOM-Elemente gefunden');
        
        // Lade Timer-Zustand falls vorhanden
        loadTimerState();
        
        // Starte die App
        initializeApp();
    } else {
        console.error('‚ùå Nicht alle n√∂tigen DOM-Elemente gefunden');
    }
}

// Warte auf DOM-Ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeDOM);
} else {
    initializeDOM();
}

// Debug-Funktionen f√ºr die Browser-Konsole
window.timerDebug = {
    getState: () => ({
        appStartTime: APP_START_TIME,
        uptimeStart: UPTIME_START,
        targetDates: TARGET_DATES,
        currentCalculations: {
            timer1: calculateTimeDifference(TARGET_DATES.timer1),
            timer2: calculateTimeDifference(TARGET_DATES.timer2),
            timer3: calculateTimeDifference(TARGET_DATES.timer3),
            timer4: calculateTimeDifference(TARGET_DATES.timer4),
            uptime: calculateElapsedTime(UPTIME_START)
        }
    }),
    resetUptime: () => {
        UPTIME_START = new Date();
        localStorage.setItem('uptimeStart', UPTIME_START.toISOString());
        saveTimerState();
        console.log('üîÑ Uptime zur√ºckgesetzt');
    },
    resetApp: () => {
        APP_START_TIME = new Date();
        UPTIME_START = new Date();
        localStorage.setItem('appStartTime', APP_START_TIME.toISOString());
        localStorage.setItem('uptimeStart', UPTIME_START.toISOString());
        saveTimerState();
        console.log('üîÑ App komplett zur√ºckgesetzt');
    },
    clearStorage: () => {
        localStorage.removeItem('appStartTime');
        localStorage.removeItem('uptimeStart');
        localStorage.removeItem('timerState');
        console.log('üóëÔ∏è Alle gespeicherten Timer-Daten gel√∂scht');
    },
    forceUpdate: () => {
        updateAllTimers();
        console.log('üîÑ Timer manuell aktualisiert');
    }
};